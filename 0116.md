# 기획 회의 및 구현 기능을 위한 기술공부
## 기획 회의 : 덥덥(DUBDUB) 기능 정리
### 우선순위 정리
### 팀원들 의견 통합
- 피그잼을 이용한 무한 토론! 기능 정리
- crazy8을 이용한 서로 생각한 기능 정리
## 스튜디오 기능을 위한 기술
### youtube-dl
- [yt-dlp](https://github.com/yt-dlp/yt-dlp/tree/master)
- 영상 렌더링용 / 편집용, 비디오 다운로드
- AI 대본 스크립트용 오디오 추출
  - WAV형식으로 추출
  - Whisper AI가 선호하는 포맷으로 전처리
### Spleeter vs FFmpeg
- 음성 배경 음악 분리
  - Spleeter는 딥러닝 기반의 음원 분리 라이브러리
  - FFmpeg는 오디오 추출은 가능하지만 음원 분리 기능은 없다.
### FFmpeg
- 음성 녹화 및 처리
  - WebRTC로부터 받은 오디오 스트림 녹음
  - AAC인코딩
  - 멀티채널 오디오 지원
- 타임라인 기반 편집
  - 음성 클립 자르기 및 이동
  - 볼륨 조절
  - 페이드 인/아웃
  - 여러 트랙 동시 편집
- 영상과 음성 합성
  - 다중 오디오 트랙 믹싱
  - 싱크 맞추기
- 실시간 재생 지원
```java
public class FFmpegService {
    private final FFmpeg ffmpeg;
    
    /**
     * 음성 녹화 (WebRTC로부터 받은 오디오 스트림 처리)
     */
    public String recordAudio(InputStream audioStream, String outputPath) {
        FFmpegBuilder builder = new FFmpegBuilder()
            .addInput(audioStream)
            .addOutput(outputPath)
            .setAudioCodec("aac")            // AAC 코덱 사용
            .setAudioChannels(2)             // 스테레오
            .setAudioSampleRate(44100)       // 44.1kHz 샘플레이트
            .setAudioBitRate(192000)         // 192kbps 비트레이트
            .done();
            
        ffmpeg.execute(builder);
        return outputPath;
    }

    /**
     * 타임라인 기반 음성 편집 (자르기, 이동, 볼륨 조절)
     */
    public String editAudioTimeline(String inputPath, List<AudioClip> clips, String outputPath) {
        // 복잡한 필터 그래프를 위한 필터 체인 생성
        StringBuilder filterComplex = new StringBuilder();
        
        // 각 클립에 대한 필터 처리
        for (int i = 0; i < clips.size(); i++) {
            AudioClip clip = clips.get(i);
            
            // 클립 자르기와 볼륨 조절을 위한 필터
            filterComplex.append(String.format("[0:a]atrim=start=%f:end=%f,volume=%f[clip%d];",
                clip.getStartTime(),
                clip.getEndTime(),
                clip.getVolume(),
                i
            ));
        }
        
        // 모든 클립 병합
        for (int i = 0; i < clips.size(); i++) {
            filterComplex.append(String.format("[clip%d]", i));
        }
        filterComplex.append(String.format("concat=n=%d:v=0:a=1[out]", clips.size()));

        FFmpegBuilder builder = new FFmpegBuilder()
            .addInput(inputPath)
            .addOutput(outputPath)
            .setComplexFilter(filterComplex.toString())
            .setAudioCodec("aac")
            .done();
            
        ffmpeg.execute(builder);
        return outputPath;
    }

    /**
     * 음성과 영상 합성 (더빙 결과물 생성)
     */
    public String mergeVideoAndAudio(String videoPath, List<String> audioPaths, String outputPath) {
        StringBuilder filterComplex = new StringBuilder();
        
        // 각 오디오 트랙에 대한 필터 설정
        for (int i = 0; i < audioPaths.size(); i++) {
            filterComplex.append(String.format("[%d:a]", i + 1));
        }
        
        // 모든 오디오 트랙 믹싱
        filterComplex.append(String.format("amix=inputs=%d:duration=longest[aout]", audioPaths.size()));

        FFmpegBuilder builder = new FFmpegBuilder()
            .addInput(videoPath)             // 메인 비디오
            .setFormat("mp4");

        // 추가 오디오 트랙들
        for (String audioPath : audioPaths) {
            builder.addInput(audioPath);
        }

        builder.addOutput(outputPath)
            .setVideoCodec("libx264")        // H.264 비디오 코덱
            .setAudioCodec("aac")            // AAC 오디오 코덱
            .setComplexFilter(filterComplex.toString())
            .setStrict(FFmpegBuilder.Strict.EXPERIMENTAL)
            .done();
            
        ffmpeg.execute(builder);
        return outputPath;
    }
}
```